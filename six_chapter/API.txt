1.阻塞：			 没有数据就将进程投入睡眠
2.非阻塞：			 没有数据且试图将进程投入睡眠才能完成时，不要将此进程投入睡眠，而是返回一个错误。(应用进程对一个非阻塞描述符循环地进行I/O调用，我们称之为轮询)
3.I/O复用：			 阻塞代替，优势是可以同时等待多个描述符就绪
4.信号驱动式I/O模型：让内核在描述符上发送SIGIO信号通知我们。
		通用步骤是，通过设置SIGIO信号的处理例程，当对端将数据发送给我们后，
		内核收到数据，然后内核给我们发送一个SIGIO信号，我们就可以处理数据了。
		
5.异步I/O:内核收到数据，并将数据复制到用户的缓存空间，这两步都由内核完成，且完成后通知用户进程I/O操作已完成。


int shutdown(int sockfd,int howto);
		1. close只是将套接字引用计数--，只有引用计数为0时才关闭套接字，而使用shutdown可以不管引用计数就激发TCP的正常终止连接序列。(四次挥手)
		2. close是关闭读和写两个方向的数据传送，但有时候出于业务需要，我们只进行半关闭状态,这时使用shutdown就有必要了。
	
	howto:
			SHUT_RD:	关闭读端，若此套接字缓存区还有数据则丢弃，之后的任何对该套接字的读调用都将失效。
			SHUT_WR:	关系写端，当前留在该套接字缓冲区中的数据都将被发送，后跟TCP的正常终止序列。
			SHUT_RDWR:  都关闭。

int poll(struct pollfd *fdarray,unsigned long nfds,int timeout);
	struct pollfd
	{
		int fd;
		short events;			//对描述符上发生的感兴趣的事件。
		short revents;			//发生在描述符集上的事件。
	};